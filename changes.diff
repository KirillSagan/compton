2d1
< import shutil
4c3
< spec_dir ='long_wakes_rad_1.2/'
---
> spec_dir ='TMCI_0.3mm_bunch/'
7c6
< path = '/s/ls4/users/kssagan/compton/'#'/home/kiruha/scince_repo/report/'
---
> path = '/s/ls4/users/kssagan/compton/'#'/home/kiruha/science_repo/compton/'
15,16c14,15
< path_to_readme = path_input + 'README.md' 
< path_to_fig = path_output + 'figures/'
---
> path_to_readme = path_input + 'README.md'
> path_to_p_loss = path_output + 'ParticleLoss/' 
21c20
< for dir_ in [bunch_filename,path_to_obj, path_to_fig]:
---
> for dir_ in [bunch_filename,path_to_obj, path_to_p_loss]:
26,29c25,26
<             pass
<     else:
<         shutil.rmtree(dir_)  
<         os.makedirs(dir_)   
---
>             pass  
>             
37c34
< #import pycuda.autoinit
---
> import pycuda.autoinit
39c36
< #from PyHEADTAIL.general.contextmanager import GPU
---
> from PyHEADTAIL.general.contextmanager import GPU
51c48
< #from PyHEADTAIL.general import pmath as pm
---
> from PyHEADTAIL.general import pmath as pm
94c91,92
< 
---
> n_scan = args.n_scan
> i = args.i
105c103
<                   'Emitty from Dy', 'Emitty 1/gamma cone limit']
---
>                   'Emitty from Dy', 'Emitty 1/gamma cone limit', 'betaxAve', 'betayAve']
123,124c121,122
< Qpx = parameters_dict['Chromaticity H']
< Qpy = parameters_dict['Chromaticity V']
---
> Qpx = 0
> Qpy = 0
155c153
< sigma_z =1.2e-3#parameters_dict['Bunch Length']*1e-3
---
> sigma_z = parameters_dict['Bunch Length']*1e-3
158c156
< epsn_y = 7.436459488204655e-09*beta*gamma
---
> epsn_y = 7.436459488204655e-09*beta*gamma # [m rad]
162a161,164
> betax_avr = parameters_dict['betaxAve']
> betay_avr = parameters_dict['betayAve']
> n_betax_avr = 10
> n_betay_avr = 8
188d189
< long_map = machine.one_turn_map[-1]
193c194
< n_macroparticles = int(1e6)
---
> n_macroparticles = int(3e5)
195,202c196,200
< n_scan = 16
< bunch_scan = list()
< for i in range(n_scan):
<     bunch_scan.append(generate_bunch(intensity, n_macroparticles, machine.transverse_map.alpha_x[0], 
<                        machine.transverse_map.alpha_y[0],machine.transverse_map.beta_x[0], 
<                        machine.transverse_map.beta_y[0], machine.longitudinal_map,
<                        machine.transverse_map.D_x[0],machine.transverse_map.D_y[0],
<                        sigma_z,gamma,p0,epsn_x,epsn_y,t))
---
> bunch = generate_bunch(intensity, n_macroparticles, machine.transverse_map.alpha_x[0], 
>                machine.transverse_map.alpha_y[0],machine.transverse_map.beta_x[0], 
>                machine.transverse_map.beta_y[0], machine.longitudinal_map,
>                machine.transverse_map.D_x[0],machine.transverse_map.D_y[0],
>                sigma_z,gamma,p0,epsn_x,epsn_y,t)
204d201
< bunch = bunch_scan[0]
210c207
<                                                       Radiation_Damping_x/t, Radiation_Damping_y/t,I2,I3,I4,None,None)
---
>                                                       Radiation_Damping_x/t, Radiation_Damping_y/t,I2,I3,I4,Dx[-1],Dy[-1])
218c215
< n_slices = 1000
---
> n_slices = 800
222,223c219,220
< factor_x = 1
< factor_y = 1
---
> factor_x = betax_avr/betax[n_betax_avr]
> factor_y = betay_avr/betay[n_betay_avr]
234c231
< get_WW(machine.beta, sigma_z, inverse=inverse, factor=factor, del_negative_t = False,
---
> get_WW(machine.beta, sigma_z, inverse=inverse, factor=factor,
246a244,279
> #transverse x
> fd, tmp_filename = tempfile.mkstemp(suffix='.txt', text=True)
> get_WW(machine.beta, sigma_z, inverse=inverse, factor=factor,
>        filename = filename_geom, list_ = ['time','dipole_x',
>                                           'quadrupole_x'], 
>        new_filename = tmp_filename, NumberPoints = NumberPoints,
>        min_z = min_z, max_z = max_z, factor_x = factor_x, factor_y = factor_y)
> 
> wake_table_geom_trans_x,slicer = make_WW(tmp_filename,bunch, n_slices = n_slices, 
>                                        fixed_cuts_perc_min_max = fixed_cuts_perc_min_max,
>                                        list_ = ['time','dipole_x',
>                                                 'quadrupole_x'],
>                                        slicing_mode = slicing_mode,
>                                        n_sigma_z = n_sigma_z)
> list_of_wake_sources_x.append(wake_table_geom_trans_x)
> os.close(fd)
> os.unlink(tmp_filename)
> 
> #transverse y
> fd, tmp_filename = tempfile.mkstemp(suffix='.txt', text=True)
> get_WW(machine.beta, sigma_z, inverse=inverse, factor=factor,
>        filename = filename_geom, list_ = ['time','dipole_y',
>                                           'quadrupole_y'], 
>        new_filename = tmp_filename, NumberPoints = NumberPoints,
>        min_z = min_z, max_z = max_z, factor_x = factor_x, factor_y = factor_y)
> 
> wake_table_geom_trans_y,slicer = make_WW(tmp_filename,bunch, n_slices = n_slices, 
>                                        fixed_cuts_perc_min_max = fixed_cuts_perc_min_max,
>                                        list_ = ['time','dipole_y',
>                                                 'quadrupole_y'],
>                                        slicing_mode = slicing_mode,
>                                        n_sigma_z = n_sigma_z)
> list_of_wake_sources_y.append(wake_table_geom_trans_y)
> os.close(fd)
> os.unlink(tmp_filename)
> 
251c284
< get_WW(machine.beta, sigma_z, inverse=inverse, factor=factor, del_negative_t = False,
---
> get_WW(machine.beta, sigma_z, inverse=inverse, factor=factor,
263a297,331
> #transverse x
> fd, tmp_filename = tempfile.mkstemp(suffix='.txt', text=True)
> get_WW(machine.beta,sigma_z, inverse=inverse, factor=factor,
>        filename = filename_rw, list_ = ['time','dipole_x',
>                                         'quadrupole_x'], 
>        new_filename = tmp_filename, NumberPoints = NumberPoints,
>        min_z = min_z, max_z = max_z, factor_x = factor_x, factor_y = factor_y)
> 
> wake_table_rw_trans_x,slicer = make_WW(tmp_filename, bunch, n_slices = n_slices, 
>                                      fixed_cuts_perc_min_max = fixed_cuts_perc_min_max,
>                                      list_ = ['time','dipole_x',
>                                               'quadrupole_x'],
>                                      slicing_mode = slicing_mode,
>                                      n_sigma_z = n_sigma_z)
> list_of_wake_sources_x.append(wake_table_rw_trans_x)
> os.close(fd)
> os.unlink(tmp_filename)
> 
> #transverse y
> fd, tmp_filename = tempfile.mkstemp(suffix='.txt', text=True)
> get_WW(machine.beta,sigma_z, inverse=inverse, factor=factor,
>        filename = filename_rw, list_ = ['time','dipole_y',
>                                         'quadrupole_y'], 
>        new_filename = tmp_filename, NumberPoints = NumberPoints,
>        min_z = min_z, max_z = max_z, factor_x = factor_x, factor_y = factor_y)
> 
> wake_table_rw_trans_y,slicer = make_WW(tmp_filename, bunch, n_slices = n_slices, 
>                                      fixed_cuts_perc_min_max = fixed_cuts_perc_min_max,
>                                      list_ = ['time','dipole_y',
>                                               'quadrupole_y'],
>                                      slicing_mode = slicing_mode,
>                                      n_sigma_z = n_sigma_z)
> list_of_wake_sources_y.append(wake_table_rw_trans_y)
> os.close(fd)
> os.unlink(tmp_filename)
265a334,341
> wake_fields_x = WakeField(slicer, *list_of_wake_sources_x)
> wake_fields_y = WakeField(slicer, *list_of_wake_sources_y)
> 
> 
> ## Putting everything at an instance of our ring (machine.one_turn_map)
> machine.one_turn_map.insert(n_betax_avr, wake_fields_x)
> machine.one_turn_map.insert(n_betay_avr, wake_fields_y)
> machine.one_turn_map.append(wake_fields_long)
267,270d342
< """## Putting everything at an instance of our ring (machine.one_turn_map)
< machine.one_turn_map.insert(1, wake_fields_long)
< machine.one_turn_map.insert(2, wake_fields_x)
< machine.one_turn_map.insert(3, wake_fields_y)"""
274,278c346,351
< intensity_scan = charge_scan/e
< n_turns = int(5e4)
< write_every = 25
< write_buffer_every = 500
< write_obj_every = 10000
---
> charge = charge_scan[i]
> intensity = charge/e
> n_turns = int(2e4)
> write_every = 5
> write_buffer_every = 250
> write_obj_every = 5000
280,321c353,368
< bunch_monitor_scan = list()
< for charge in charge_scan:
<     charge = charge*1e9 
<     new_bunch_filename = bunch_filename+f'charge={charge:.3}nC'.replace('.',',')
<     bunch_monitor_scan.append(BunchMonitor(
<         filename=new_bunch_filename,n_steps=int(n_turns/write_every),
<         write_buffer_every=write_every,
<         parameters_dict={'Q_x': Q_x,'Q_y':Q_y},
<         stats_to_store = [
<             'mean_z', 'mean_dp',
<             'sigma_z', 'sigma_dp']))
< 
< 
< ## The function that performs the calculation with different intensities
< def run(bunch, intensity,bunch_monitor):  
<     current = intensity*e/t*1e3
<     sigma_z_scan = list()
<     sigma_E_scan = list()
<     update_bunch(bunch,intensity,
<                  bunch_dict,beta,gamma,p0)
<     
<     sigma_z_scan.append(bunch.sigma_z()*1e3)
<     sigma_E_scan.append(bunch.sigma_dp()*1e4)
<     bunch_dict_new = make_dict(bunch)
<     save_obj(path_to_obj,bunch_dict_new,f'bunch_data_charge={intensity*e*1e9:.3}nC_turn={0}')
<     for i in range(n_turns):
<         long_map.track(bunch)
<         wake_fields_long.track(bunch)
<         radiation_long.track(bunch)
<         if (i+1)%write_every == 0:
<             sigma_z_scan.append(bunch.sigma_z()*1e3)
<             sigma_E_scan.append(bunch.sigma_dp()*1e4)
<             bunch_monitor.dump(bunch)
<         if (i+1)%write_obj_every == 0:
<             bunch_dict_new = make_dict(bunch)
<             save_obj(path_to_obj,bunch_dict_new,f'bunch_data_charge={intensity*e*1e9:.3}nC_turn={i}')
<         if (i+1)%n_turns == 0:
<             plot_sigma_z_sigma_E(sigma_z_scan,sigma_E_scan,n_turns,write_every,
<                                      current,path=path_to_fig) 
<             plot_longitudinal_phase_space(bunch_,current,path=path_to_fig) 
<             
<     return [np.array(sigma_z_scan[-500:-1]).mean(), np.array(sigma_E_scan[-500:-1]).mean()]
---
> cons = range(1,7)
> #names_long = ['S_n_long_'+f'{i}' for i in cons]
> names_trans = ['S_n_trans_'+f'{i}' for i in cons]
> names_trans_y = ['S_n_trans_y_'+f'{i}' for i in cons]
> #bunch_monitor_scan = list()
> 
> charge = charge*1e9 
> new_bunch_filename = bunch_filename+f'charge={charge:.3}nC'.replace('.',',')
> bunch_monitor = BunchMonitor(
> 		filename=new_bunch_filename,n_steps=int(n_turns/write_every),
> 		write_buffer_every=write_every,
> 		parameters_dict={'Q_x': Q_x,'Q_y':Q_y},
> 		stats_to_store = [
> 		    'mean_z', 'mean_dp','mean_x','mean_y',
> 		    'sigma_z', 'sigma_dp', 'sigma_x','sigma_y',
> 		    'epsn_x', 'epsn_y',*names_trans,*names_trans_y])
323,325d369
< iterable = list()
< for bunch_i,intensity_i, bunch_monitor_i in zip(bunch_scan, intensity_scan, bunch_monitor_scan):
<     iterable.append((bunch_i,intensity_i,bunch_monitor_i))
328,329d371
< from multiprocessing import Process, Pool
< processes = n_scan ## Numbers of threads used for calculation
332,364d373
< with Pool(processes = processes) as pool:
<     results = list(pool.starmap(run,iterable))
<     
< print(f'compute time = {time.time()-t0}')
< 
< ## Plot dependence of sigma z and sigma E on currents
< sigma_z_plt = list()
< sigma_E_plt = list()
< [[sigma_z_plt.append(result[0]), sigma_E_plt.append(result[1])] for result in results]
< 
< charge_scan = charge_scan*1e9
< fig, (ax1, ax3) = plt.subplots(2,1,figsize = (10,6))
< line1, = ax1.plot(charge_scan,sigma_z_plt,'-', c='r')
< ax1.set_xlabel('charge [nC]')
< ax1.set_ylabel('sigma_z [mm]')
< ax1.set_title(f'dependence of sigma_z on charge')
< ax1.grid()
< 
< line3, = ax3.plot(charge_scan,sigma_E_plt,'-', c='r')
< ax3.set_xlabel('charge [nC]')
< ax3.set_ylabel('sigma_E [1e-4]')
< ax3.set_title(f'dependence of sigma_E on current')
< ax3.grid()
< ax1.scatter(current_scan, sigma_z_plt, color='r', s=20, marker='s')
< ax3.scatter(current_scan, sigma_E_plt, color='r', s=20, marker='s')
< 
< plt.tight_layout()
< plt.show()
< 
< fig.savefig(path_to_fig+'sigma_z_sigma_E_charge.jpg')
< save_obj(path_to_obj, [sigma_z_plt,sigma_E_plt],'data_for_plot')
< 
< print(f'computing time per turn = {(time.time()-t0)/60/n_turns} min')
365a375,401
> try:
>     update_bunch(bunch, intensity,
>                  bunch_dict, beta, gamma, p0)
>     print(f'intensity = {intensity:.3e}')
>     for i in range(n_turns):
>         if (time.time()-t0)/60/60 >= (24*3-0.1):
>             raise RuntimeError      
>         with GPU(bunch) as context:
>             machine.track(bunch)
>         radiation_long.track(bunch)
>         radiation_transverse.track(bunch)
>         if (i+1)%write_every == 0:
>             bunch_monitor.dump(bunch)
>         if (i+1)%write_obj_every == 0:
>             bunch_new_dict = make_dict(bunch)
>             save_obj(path_to_obj,bunch_new_dict,f'beam_charge={charge:.3}nC_i={i}')
> except:
>     filename_err = path_to_obj + f'charge={charge:.3e}nC_err_logs.txt'.replace('.',',')
>     log_info = traceback.format_exc()
>     print(log_info)
>     with open(filename_err, 'w') as f:
>         f.write(log_info)
>     
> finally:
>     print(f'Qpx = {Qpx}\tQpy = {Qpy}\nCharge={charge:.3}nC\nTurn={i}\nComputing time per turn = {(time.time()-t0)/60/n_turns} min')
>     bunch_dict = make_dict(bunch)
>     #save_obj(path=path_to_obj, obj=bunch_dict, name=f'turns={i},charge={charge:.3e}nC')
